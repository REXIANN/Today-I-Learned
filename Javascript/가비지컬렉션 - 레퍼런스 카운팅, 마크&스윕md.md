# 가비지컬렉션 - 레퍼런스 카운팅, 마크&스윕

출처: 유튜브-우테코
태그: 브라우저

자바, 자바스크립트, 파이썬, 고랭 등의 언어는 프로그래머가 메모리를 할당하고 해제하는 것을 신경쓸 필요가 없다. 가비지컬렉터가 있기 떄문이다. 

사용이 끝난 객체를 알아서  메모리 공간에서 지워주는 좋은 도구인 가비지 컬렉터를 알아보자

## Reference Counting

선언하는 모든 객체들은 레퍼런스 카운트 라는 값을 가지게 된다. 이 값이 0 이 되는 순간 가비지 컬렉터에 의해 제거된다. Rc()의 값은 해당 객체가 몇 군데에서 참조되고 있는지에 대한 값이다.

```jsx
function run() {
	let a = {}; // Rc(a) = 1
	{
		let b = {}; // Rc(b) = 1
		a.test = b {}; // Rc(b) = 2
	}
	// Rc(b) = 1
}

run();
// Rc(a) = 0 -> Remove a
// Rc(b) = 0 -> Remove b
```

여기서 a.test = b 를 하는 순간 Rc(b) 가 2 가 되는 이유는 b 객체가 a.test 를 이용해서 접근이 가능하기 때문이다. 블록을 벗어나는 순간 let으로 선언된 b 객체는 let 변수에 할당되었기 떄문에 b 라는 이름으로는 안쪽 블록스코프 바깥쪽에서 사용될 수 없다. 그러므로 레퍼런스 카운트는 다시 1 이 감소하게 되고, a.test 를 이용해서 접근 가능한 카운트 1 만 남는다.

레퍼런스 카운트 방식의 가비지컬렉션은 굉장히 간단하다. 객체마다 카운트를 하나씩 주고, 매번 레퍼런스 카운트 계산을 해주면서 값이 0인가 보기만 하면 되기 때문이다. 그래서 새로운 언어를 만들 때 레퍼런스 카운트 방식의 가비지 컬렉터를 사용하는 경우가 많다고 한다. 이후 가비지 컬렉터의 여러 문제를 보완해나가는 방식이 된다.

하지만 이 방식의 경우 문제가 있을 수 있다.

```jsx
{
	let a = {}; // Rc(a) = 1
	let b = {}; // Rc(b) = 1

	a.test = b; // Rc(a) = 2
	b.test = a; // Rc(b) = 2
}
// Rc(a) = 1
// Rc(b) = 1
```

두 객체를 블록 스코프를 벗어나는 순간 접근할 방법이 없어진다. 다시 말해 두 객체는 메모리 상에서 사라져야 한다. 그러나 두 객체의 레퍼런스 카운트는 둘 다 0이 아니므로 레퍼런스 카운팅 방식의 가비지 컬렉터는 해당 객체를 삭제하지 않는다.

이처럼 상호참조나 순환참조가 발생해 버리는 경우 레퍼런스 카운팅 방식으로는 해결을 할 수가 없다. 

이처럼 레퍼런스 카운팅 방식은 개념도 간단하고 구현도 간단하다. 하지만 순환참조 문제가 있고 이를 레퍼런스 카운팅 방식으로는 해결할 수 없기 때문에 메모리 누수가 생길 수 있다. 이런 문제를 조금 더 보완하고자 약함 참조(weak reference) 등의 기능을 제공하기도 하지만 “프로그래머가 메모리 관리에 신경을 쓸 필요가 없게 한다” 라는 가비지 컬렉션의 핵심 기능에 반한다.

이를 보완하기 위해 다른 방법을 같이 사용하거나, 아예 다른 방법으로 가비지 컬렉션을 만든다. 그 방법 중 하나가 마로 마크&스윕(Mark & Sweep) 이라는 방식이다. 

## Mark & Sweep

```jsx
{
	let a = {};
	let b = {};

	a.test = b;
	// We are here
}
```

마크&스윕의 경우 루트 객체가 하나 있다. 그리고 코드를 실행하면서 나오는 객체들은 전부 루트 객체의 자식으로 넣는다. 그 이후 객체간의 참조에 따라 엮어준다. 이렇게 엮어주는 작업은 레퍼런스 카운팅처럼 매번 하는 것이 아니라 의도적으로 가비지 컬렉팅 기능을 실행시켜야 한다. 일정 주기마다 돌릴 수도 있고, 메모리가 일정 퍼센트 이상 사용되었을 때 가비지 컬렉팅을 수행할 수도 있다. 순회 방법에도 여러 방법이 있을 수 있으나 우선 깊이를 기반으로 마킹을 한다고 해보자.

이제 정기적으로 컬렉팅을 수행하면서 루트객체와 연결이 되어 있지 않은 객체들은 더이상 사용될 수 없는 존재들이므로 지워버린다. 

마크&스윕 방식의 가비지 컬렉션은 기본 개념이 어려워서 구현 난이도가 높은 것이 아니다. 개념은 단순하고 직관적이지만 실제로 컴퓨터에서 적절한 성능으로 돌리기 위해서는 필요한 최적화 작업이 상당히 많아서 어려운 것이다.

마크&스윕 방식은 레퍼런스 카운팅은 해결할 수 없는 순환참조 문제를 해결할 수 있다. 루트 객체에서부터 순환을 시작하기 때문이다. 하지만 가비지 컬렉션도 문제가 있다.

레퍼런스 카운팅은 객체가 참조될 때 마다 카운트만 추가하면 되기 때문에 실해에 별 문제가 없었다. 하지만 마크&스윕 방식은 가비지 컬렉팅을 하기 위해서는 항상 루트객체에서 시작하여 모든 객체를 훑어보아야 한다. 코드가 조금만 복잡해져도 가벼운 작업이 아니게 된다. 마크&스윕은 적당히 컨셉만 구현한다면 만든 프로그램은 곧 멈추게 된다. 실제로 안드로이드 OS 의 경우, 출시 초기에 가비지 컬렉션의 최적화가 덜 되어 사용자가 사용 시 앱이 느려지거나 멈추는 문제가 종종 있었다고 한다.

그래서 마크&스윕은 최적화에 많은 고민이 필요하다. 언제 가비지 컬렉션을 돌릴지부터 시작해서, 한번 돌릴때 최대한 비용이 적게 들게끔 계산을 해야 한다.

~~가비지 컬렉션이 없어도 메모리 관리를 자동으로 할 수 있는 러스트가 짱짱맨이라고 한다.~~