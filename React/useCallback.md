# useCallback 은 무엇일까?
`useCallback`은 하나의 콜백함수를 메모이제이션(memoization) 하기 위해 사용한다.
의존성 배열에 있는 값이 변하지 않는 이상 `useCallback` 으로 선언된 함수는 다시 실행되지 않으며, 호출할 경우 이전 상태의 값을 즉시 반환한다.

컴포넌트가 다시 렌더링 될 때 리액트는 컴포넌트가 사용하는 props 와 state 의 상태(변경이 되었는지)를 확인한다.
변경된 부분이 있다면 컴포넌트를 업데이트 하고 해당 state 나 props 를 사용하는 children 을 업데이트 한다.

이 과정은 만약 컴포넌트가 거대하거나 많은 children을 가지고 있다면 상당히 비싼 작업이 될 수 있다(해당 컴포넌트와 하위 컴포넌트에 대한 virtual DOM 을 다시 만들고 변경점을 전부 비교해야 하기 떄문).
하지만 `useCallback`을 사용한 콜백함수를 이용한다면 의존성배열에 넣은 값이 바뀌지 않는 한 동일한 콜백함수를 여러번 실행하는 일은 존재하지 않는다.

이 과정은 특히 다음과 같은 상황에서 유리하다.
* 특정 콜백함수를 자식 컴포넌트에 넘겨줘야 할 때
* 특정 이벤트에 대해서만 콜백함수가 실행되어야 할 때
* 콜백함수가 루프 안에서 실행될 때 -> 콜백함수는 루프를 돌면서 각 루프안에서 실행될 때 마다 새로운 closure 를 갖는데 이로 인한 closure 관련 문제를 해결할 수 있다.

## 의존성 배열(dependency array)
의존성 배열에는 메모하고자 하는 콜백함수에서 실행되는 모든 변수와 함수들이 들어가야 한다.
변수는 동등비교(`===`)를 한다 치고, 함수는 어떻게 비교할까? 함수는 넣지 않아도 되는 건 아닐까?

답은 '넣어야 한다' 이다. 

리액트에서는 `useCallback` 안에서 사용하는 모든 함수와 변수를 (다른 의도가 있는 것이 아니라면) 넣도록 권장하고 있다.
`useCallback` 함수를 실행할 지의 여부는 의존성 배열에 들어있는 함수도 판단하는 대상이 되는데, 함수는 `Object.is` 메서드를 사용해서 비교한다.

리액트는 의존성 배열에 들어 있는 함수가 변경되었는지 확인하기 위해 참조 동등성(reference equality)을 사용한다.
참조 동등성을 비교하여 함수의 내용이 아니라 함수 레퍼런스를 비교하여 이전 상태에 존재하는 함수와 동일한 레퍼런스인지(해당 함수가 새로 만들어졌는지) 를 판별하는 것이다.

함수가 컴포넌트 내부에 정의되면 컴포넌트가 렌더링 될 때 마다 내부에 있는 함수도 다시 실행되기 때문에 함수의 레퍼런스도 같이 변경된다.
즉, 이전 렌더링에서의 함수 레퍼런스는 현재 함수 레퍼런스와 같지 않으며 리액트는 함수가 변경되었다고 판단한다.

만일 함수가 컴포넌트 외부에 선언되었다면 해당 함수는 컴포넌트가 처음 생성될 때 단 한개의 레퍼런스만을 가지게 된다.
따라서 리액트는 이 함수가 변경되지 않는다고 판단하며 항상 동일한 레퍼런스를 참조하여 함수를 실행하고 값을 가져온다.

## `Object.is`
`Object.is` 는 자바스크립트에서 두 개의 값이 같은지 비교하는 메서드이다.
`===` 연산자의 강화된 버전이라고 보면 된다.

`Object.is` 메서드는 두 개의 값이 같은지, 타입이 같은지, 그리고 내용이 같은지 확인 하고 불리언 형태의 값을 반환한다. 
오브젝트의 경우 내용이 같은지는 보지 않고 레퍼런스가 동일한지를 확인한다.

`Object.is`의 비교는 `===` 연산자와 다른 점이 몇가지가 있는데 그 중 대표적인 두개는 다음과 같다.
* `+0` 과 `-0`: `Object.is`는 false 를 반환하지만 `===` 은 true 를 반환한다.
* `NaN`과 `NaN`: `Object.is`는 true 를 반환하지만 `===` 은 false 를 반환한다.

### `NaN`과 `NaN` 의 비교는 왜 false 일까?
자바스크립트에서 `NaN`은 어떠한 값이 숫자가 아님을 나타내는, 다소 특별한 값이다.
그러나 `NaN`은 그 어떠한 다른 값과도 같지 않은 것으로 취급된다. 그렇기에 동등성 비교에서 false 가 반환되는 것이다.

`NaN`이 이렇게 동작하는 이유는 `NaN`이 내부적으로는 특정 숫자가 아니라 정의되지 않거나 표현할 수 없는 값에 대한 마커(marker)로 사용되기 때문이다.
일반적으로는 숫자를 숫자가 아닌 값으로 나누거나 0의 제곱근을 구하는 등의 정의되지 않은 수학 연산의 결과값으로 나온다.

그래서 어떠한 연산의 값이 `NaN` 인지 확인하려면 `Number.isNaN()` 메서드를 사용해야 한다.

참고로 `NaN`의 타입은 `number` 타입이다(...). 

### 대체 왜 `NaN` 이 number 타입이야?
그 이유는 `NaN` 은 자바스크립트에서 사용되는 이진 표현(binary representation)에서 숫자 값으로 저장되기 때문이다.

`NaN`은 주로 수학 연산에서의 오류가 났을 때 에러를 뱉는 대신 `NaN`을 반환하기 위해 설계된 값이기 때문에 숫자 값으로 저장되며,
이를 통해 모든 수학적 연산에서 number 타입을 사용하여 일관된 표현이 가능하게 해준다. 

이를 확인해보려면 어떠한 수학적 연산에서 수식에 있는 숫자 중 하나를 `NaN`을 넣어보면 알 수 있다. 
결과값은 항상 `NaN`이 될 것이다.
